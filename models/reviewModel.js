const mongoose = require('mongoose')
const Tour = require('./tourModels')

const reviewSchema = new mongoose.Schema(
    {
        review: {
            type: String,
            required: [true, 'review cannont be empty']
        },
        rating: {
            type: Number,
            min: 1,
            max: 5
        },
        createdAt: {
            type: Date,
            default: Date.now
        },
        tour: { // here we are creating a property called tour
            type: mongoose.Schema.ObjectId, // here we are telling mongoose that the type of data is of the mongoose schema objectId type
            ref: 'Tour', // Here we are telling mongoose that the data is from the Tour model 
            required: [true, 'Review must belong to a tour']
        },
        user: { // here we are creating a property called   
            type: mongoose.Schema.ObjectId, // here we are telling mongoose that the type of value it will have will be an objectId thats generated by the mongodb
            ref: 'User', // here we are telling mongoose that this "user" property is refering to the document in the User model which if found by mongodb by using the mongodb user id which is the value of the user field.
            required: [true, 'A review must belong to a user'] // here we are telling mongoose that this field must present in the document as true stipulates that, other wise mongoose will take the string adjacent to this booleen value and use this as a messahe in an error.
        },
    },
    { // this is the options parameter of the class where we insert an object. 
        toJSON: {virtuals: true}, // In this case we are saying that we want the virtual properties to be in json format when they are produced. Virtual properties are properties that are not actually saved to the database.
        toObject: {virtuals: true} // here we are saying that we want the virtual properties to be objects. 
    }
)

reviewSchema.index({tour: 1, user: 1}, {unique: true}) // Basically the way this works is that every time a new Review document is created, a new document or "index" is also created with the properties tour and user and because we have set the options parameter to unique: true, we are telling mongoose that before creating and saving the next review document, it must first check in the index's to see if there is already a document in the index that contains the same user and tour property values. If there is already an index with the same tour and user properties then that means that mongoose wont save the new review document to the database because it is unable to add its tour and user properties doc to the index.

// "this" is pointing to the query
reviewSchema.pre(/^find/, function(next){
    // this.populate({
    //     path: 'tour',
    //     select: 'name'
    // }).populate({ // we have to use the populate method each time we want to populate the property with details because the populate method returns the query.
    //     path: 'user',
    //     select: 'name photo'
    // })

    // Before the query is sent off we are telling it to populate the users property in the document it returns with the name and photo properties that are inside the actual users document in the mongodb database.
    this.populate({ // here we have to use the populate method on the query ('this) because we want to populate the 'user' property with details from "select: 'name photo'" which comes from the database.
        path: 'user', // Here we are telling mongoose that when a query is made that starts with /^find/, the returned data that is inside that property 'user' must include the 'name' and 'photo' from the 'user' property in the database. This is possible because the 'user' property inside the database contains these pieces on information.
        select: 'name photo'
    })

    next()
})

reviewSchema.statics.calcAverageRatings = async function(tourId){ // Here we are creating a property called calcAverageRatings in the statics method and assigning it to an anonomous function. Because this property is inside the statics object, that means that the property can only be accessed via the model it belongs too (Review)
    // inside a static method, 'this' points to the current model.
    const stats = await this.aggregate([
        {
            $match: {tour: tourId} // Here mongoose checks through all of the index's that have tourId's and when it finds them all it then goes into the complete tour documents and retreaves them all.
        },
        {
            $group: { // After retreaving all the tour documents mongoose then will then create a one object group according to the specifications
                _id: '$tour', // the _id property of the group will be the tour properties value of each of the review documents and since they all have the same value for this property it will be the identifier of the group.
                nRating: {$sum: 1}, // the nRating property in the grouped object will be the sum off all the review documents that were used to make the group
                avgRating: {$avg: '$rating'} // the avgRating property in this new group will have the value of the average of the rating properties of each of the review documents.
            }
        }
    ])

    if (stats.length > 0) { // If there are reviews in the data base then this happens
        await Tour.findByIdAndUpdate(tourId, {
            ratingsQuantity: stats[0].nRating,
            ratingsAve: stats[0].avgRating
        })
    } else { // else we reset  the properties of the tour to the initial default settings
        await Tour.findByIdAndUpdate(tourId, {
            ratingsQuantity: 0,
            ratingsAve: 4.5
        })
    }
}

//Here we are using a 'post' save method which means that after the document is saved to the database the function will be executed which basically retreaves all the review documents with the same tour id and then groups them as per our aggregate.
reviewSchema.post('save', function(){ // we dont have access to the next() function because it is not appart of the POST save method because one the document is already saved to the database the req has finished going through our API.
    // 'this' points to the current review document and 'this.constructor' points to the actual object that created the document which is the Review model. The reason why we have to refer to it this way is because we dont define the Review document until after as below on line 77.
    this.constructor.calcAverageRatings(this.tour) 
    
})

// Here we are creating a middleware before the functions findByIdAndDelete and findByIdAndUpdate are called but these functions are only 'short-hands' for findOneAndUpdate and findOneAndDelete and so therefore we must use a regular expression referring to these functions (findOneAndUpdate and findOneAndDelete) for it wouldnt work if we were to use a regular expression referring to these functions (findByIdAndDelete and findByIdAndUpdate).
reviewSchema.pre(/^findOneAnd/, async function(next){
    this.r = await this.findOne() // Before the findByIdAndDelete and findByIdAndUpdate methods are called we need to get the actual review document from the data base and so what we do is call the find() method on the actual query (such a query is on line 20 in handlerFactory.js but we access it using 'this') and since the query has all the methods still inside it and the data from the req containing the review Id is still inside it too, we can use the find() method on the query to return the actual review document from the database.
    // After the query returns the data from the database, the query still exists, it hasnt gone anywhere, so on line 86 we create a property inside the query called r and we assign it to the returned document. Thus now that we have inserted the document into the query, we can access the document in other middlewars via the query.
    next()
})

reviewSchema.post(/^findOneAnd/, async function(){
    // await this.findOne(); does NOT work here, query has already executed
    await this.r.constructor.calcAverageRatings(this.r.tour)
})

const Review = mongoose.model('Review', reviewSchema) // Mongoose will automatically plurarize the model name "Review" to reviews as a collection in the database when the first document is created in the database

module.exports = Review